Харківський університет радіоелектроніки Факультет комп'ютерних наук Кафедра програмної інженерії




ЗВІТ
до лабораторного заняття №3 з дисципліни "Програмування під Android"
на тему "Створення калькулятору"






Виконала ст. гр. ПЗПІ-23-2 Колодіюк Надія Сергіївна



Перевірив
ст. викладач кафедри ПІ Сокорчук Ігор Петрович









Харків 2024
МЕТА

Навчитися	розробляти	застосунки	із	мінімальною	логікою.
Навчитися розробляти адаптивні застосунки для Android.

ЗАВДАННЯ


Розробити калькулятор на 4 базові арифметичні операції з кнопками для введення аргументів і дій.

Калькулятор повинен мати адаптивний користувацький інтерфейс у різних орієнтаціях екрану та на екранах різної роздільної здатності.

ХІД РОБОТИ

Оскільки користувацький інтерфейс калькулятору має адаптуватися до різних орієнтацій екрану та правильно відображатися на екранах різної роздільної здатності, для розмітки була обрана GridLayout. Крім того, цей макет дозволяє організувати елементи інтерфейсу у вигляді сітки, що є оптимальним варіантом для побудови калькулятора, інтерфейс якого у звичному для користувача форматі представляє собою таблицю або сітку.
У розмітках GridLayout можна встановлювати кількість рядків та стовпців (у кореневому вузлі GridLayout), а також регулювати розмір кожної кнопки (columnSpan) та її позиціонування у межах сітки (layout_row, layout_column). Це дозволяє налаштовувати відображення, щоб кнопки виглядали однаково на різних екранах та займали потрібний простір відносно екрану та одне одного. Таким чином можна уникнути створення окремих розміток для ландшафтної та вертикальної орієнтацій екрану.
Для виконання арифметичних операцій використовується алгоритм сортувальної станції (shunting yard algorithm). Введені користувачем вирази з врахуванням пріоритету операцій конвертуються у постфіксну нотацію.
Метод convertToPostfix, наведений у додатку А, ітерує по списку токенів, введених користувачем. Якщо токен є числом, він одразу додається до результату в постфіксній нотації. Якщо токен є оператором, його розташування залежить від пріоритету: поточний оператор додається до постфіксного виразу, якщо його пріоритет нижчий за пріоритет оператора на вершині стеку, або кладеться на стек операторів. Після завершення ітерації всі оператори, що залишилися у стеку, додаються до постфіксного виразу.
Метод evaluatePostfix, наведений у додатку Б, обчислює значення виразу у постфіксній нотації. Він ітерує по списку токенів, поки не дійде до кінця. Якщо токен є числом, воно кладеться на стек. Якщо токен є оператором, зі стеку знімаються два числа, над якими виконується операція, визначена оператором. Отриманий результат повертається назад на стек. Після завершення ітерації стек містить єдиний елемент — результат обчислення.
ВИСНОВКИ

Посилання на репозиторій з програмним кодом створеного застосунку: https://github.com/NureKolodiiukNadiia/android-pzpi-23-2- kolodiiuk-nadiia/LabTask3/android-pzpi-23-2-kolodiiuk-nadiia-lab-task3. Посилання на відеозапис: https://youtu.be/sB5npjYxPC0 .
ВИКОРИСТАНІ ДЖЕРЕЛА
    1. Contributors to Wikimedia projects. Shunting yard algorithm - Wikipedia. Wikipedia, the free encyclopedia. URL: https://en.wikipedia.org/wiki/Shunting_yard_algorithm (date of access: 17.01.2025).
    2. Відеозвіт. URL: https://youtu.be/sB5npjYxPC0 .
ДОДАТОК А

Метод convertToPostfix


1	private ArrayList<String> convertToPostfix() {	
2	ArrayList<String> postfix = new ArrayList<>();	
3	Stack<String> operators = new Stack<>();	
4	for (String token : expression) {	
5	if (isNumber(token)) {	
6	postfix.add(token);	
7	} else if (isOperator(token)) {	
8	while (!operators.isEmpty()	
9	&& getPrecedence(operators.peek())	>=
10	getPrecedence(token)) {	
11	postfix.add(operators.pop());	
12	}	
13	operators.push(token);	
14	}	
15	}	
16		
17	while (!operators.isEmpty()) {	
18	postfix.add(operators.pop());	
19	}	
20	return postfix;	
ДОДАТОК Б

Метод evaluatePostfix

    1 private double evaluatePostfix(ArrayList<String> postfix) {
    2 Stack<Double> values = new Stack<>(); 3
    4 for (String token : postfix) {
    5 if (isNumber(token)) {
    6 values.push(Double.parseDouble(token));
    7 } else {
    8 if (values.size() < 2) {
    9 throw new IllegalStateException("Invalid expression");
10	}
    11 double b = values.pop();
    12 double a = values.pop();
    13 values.push(performOperation(a, b, token));
14	}
15	}
16
17	if (values.size() != 1) {
18	throw new IllegalStateException("Invalid expression");
19	}
20
21	return values.pop();
